<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mysql基础]]></title>
    <url>%2F2019%2F05%2F26%2FMysql%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[今日内容1. DQL:查询语句 1. 排序查询 2. 聚合函数 3. 分组查询 4. 分页查询 2. 约束 3. 多表之间的关系 4. 范式 5. 数据库的备份和还原 DQL:查询语句1. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 3. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 4. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot; 约束* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; * 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; * 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计1. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 -- 创建旅游线路分类表 tab_category -- cid 旅游线路分类主键，自动增长 -- cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); -- 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100) ); /* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 2. 数据库设计的范式 * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 * 分类： 1. 第一范式（1NF）：每一列都是不可分割的原子数据项 2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） [https://www.zhihu.com/question/24696366/answer/29189700](https://www.zhihu.com/question/24696366/answer/29189700 &quot;范式详解-知乎&quot;) 数据库的备份和还原1. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 2. 图形化工具：]]></content>
      <categories>
        <category>Java</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础]]></title>
    <url>%2F2019%2F05%2F24%2FMysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今日内容 数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL 数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQL 4. 常见的数据库软件 * 参见《MySQL基础.pdf》 MySQL数据库软件1. 安装 * 参见《MySQL基础.pdf》 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据 SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;]]></content>
      <categories>
        <category>Java</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F05%2F17%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射：框架设计的灵魂* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 * 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。 * 获取Class对象的方式： 1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 12345678910111213141516171819202122232425262728293031323334 public class ReflectDemo1 &#123; /** 获取Class对象的方式： 1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 2. 类名.class：通过类名的属性class获取 3. 对象.getClass()：getClass()方法在Object类中定义着。 */ public static void main(String[] args) throws Exception &#123; //1.Class.forName(&quot;全类名&quot;) Class cls1 = Class.forName(&quot;cn.itcast.domain.Person&quot;); System.out.println(cls1); //2.类名.class Class cls2 = Person.class; System.out.println(cls2); //3.对象.getClass() Person p = new Person(); Class cls3 = p.getClass(); System.out.println(cls3); //== 比较三个对象 System.out.println(cls1 == cls2);//true System.out.println(cls1 == cls3);//true Class c = Student.class; System.out.println(c == cls1); &#125;&#125; * Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ReflectDemo2 &#123; /** Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() * Field getField(String name) * Field[] getDeclaredFields() * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取类名 * String getName() */ public static void main(String[] args) throws Exception &#123; //0.获取Person的Class对象 Class personClass = Person.class; /* 1. 获取成员变量们 * Field[] getFields() * Field getField(String name) * Field[] getDeclaredFields() * Field getDeclaredField(String name) */ //1.Field[] getFields()获取所有public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125; System.out.println(&quot;------------&quot;); //2.Field getField(String name) Field a = personClass.getField(&quot;a&quot;); //获取成员变量a 的值 Person p = new Person(); Object value = a.get(p); System.out.println(value); //设置a的值 a.set(p,&quot;张三&quot;); System.out.println(p); System.out.println(&quot;===================&quot;); //Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); &#125; //Field getDeclaredField(String name) Field d = personClass.getDeclaredField(&quot;d&quot;); //忽略访问权限修饰符的安全检查 d.setAccessible(true);//暴力反射 Object value2 = d.get(p); System.out.println(value2); &#125;&#125; * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ReflectDemo3 &#123; /** Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() * Field getField(String name) * Field[] getDeclaredFields() * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取类名 * String getName() */ public static void main(String[] args) throws Exception &#123; //0.获取Person的Class对象 Class personClass = Person.class; /* 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() */ //Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor constructor = personClass.getConstructor(String.class, int.class); System.out.println(constructor); //创建对象 Object person = constructor.newInstance(&quot;张三&quot;, 23); System.out.println(person); System.out.println(&quot;----------&quot;); Constructor constructor1 = personClass.getConstructor(); System.out.println(constructor1); //创建对象 Object person1 = constructor1.newInstance(); System.out.println(person1); Object o = personClass.newInstance(); System.out.println(o); //constructor1.setAccessible(true); &#125;&#125; * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ReflectDemo4 &#123; /** Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() * Field getField(String name) * Field[] getDeclaredFields() * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取类名 * String getName() */ public static void main(String[] args) throws Exception &#123; //0.获取Person的Class对象 Class personClass = Person.class; /* 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) */ //获取指定名称的方法 Method eat_method = personClass.getMethod(&quot;eat&quot;); Person p = new Person(); //执行方法 eat_method.invoke(p); Method eat_method2 = personClass.getMethod(&quot;eat&quot;, String.class); //执行方法 eat_method2.invoke(p,&quot;饭&quot;); System.out.println(&quot;-----------------&quot;); //获取所有public修饰的方法 Method[] methods = personClass.getMethods(); for (Method method : methods) &#123; System.out.println(method); String name = method.getName(); System.out.println(name); //method.setAccessible(true); &#125; //获取类名 String className = personClass.getName(); System.out.println(className);//cn.itcast.domain.Person &#125;&#125; * 案例： * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法 123456789101112131415161718192021222324252627282930313233343536373839public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //可以创建任意类的对象，可以执行任意方法 /* 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法 */ /* Person p = new Person(); p.eat();*//* Student stu = new Student(); stu.sleep();*/ //1.加载配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录下的配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;pro.properties&quot;); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat&Servlet笔记]]></title>
    <url>%2F2019%2F04%2F13%2FTomcat_Servlet%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今日内容1. web相关概念回顾 2. web服务器软件：Tomcat 3. Servlet入门学习 web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 * Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\hello&quot; /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet* 概念：运行在服务器端的小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门： 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; * 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名 4. tomcat会将字节码文件加载进内存，并且创建其对象 5. 调用其方法 * Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 * Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 * @WebServlet(&quot;资源路径&quot;) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; } IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 * 查看控制台的log：Using CATALINA_BASE: &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot; 2. 工作空间项目 和 tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo分类无法显示]]></title>
    <url>%2F2019%2F04%2F12%2Fhexo%E5%88%86%E7%B1%BB%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[步骤一： 由于默认是没有tags和categories的，命令行: hexo new page “tags” hexo new page “categories” 第二步： 编辑\source\tags\index.md 123456---title: 文章分类date: 2019-04-11 00:35:13type: &quot;tags&quot;layout: &quot;tags&quot;--- 编辑\source\categories12345---title: categoriesdate: 2019-04-11 01:01:07type: &quot;categories&quot;---]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 图片无法显示]]></title>
    <url>%2F2019%2F04%2F12%2Fhexo-%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[遇到这样的问题 解决方法1.首先确认站点_config.yml（hexo根目录下的那个） 中有 post_asset_folder: true。(空一格)Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.hexo n “demo” 4.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：demo文件夹–figure2.pngdemo.md 图片要和文章所在的文件夹在一起，写成这样就可以了，在demo.md 插入你要插入的图片的位置写如下： {% asset_img figure2.png This is an example image %} /*修改figure2.png，figure2.png应在[demo文件夹中]*/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒹葭]]></title>
    <url>%2F2019%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。 蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。 蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>诗经</tag>
        <tag>古典文学</tag>
      </tags>
  </entry>
</search>
