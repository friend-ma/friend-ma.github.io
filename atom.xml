<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>兴趣使然的程序猿.hub</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.friend-ma.top/"/>
  <updated>2019-05-26T07:36:57.793Z</updated>
  <id>www.friend-ma.top/</id>
  
  <author>
    <name>friend-ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql进阶</title>
    <link href="www.friend-ma.top/2019/05/26/Mysql%E8%BF%9B%E9%98%B6/"/>
    <id>www.friend-ma.top/2019/05/26/Mysql进阶/</id>
    <published>2019-05-26T07:18:08.000Z</published>
    <updated>2019-05-26T07:36:57.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;        -- 按照性别分组。分别查询男、女同学的平均分,人数        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页        SELECT * FROM student LIMIT 3,3; -- 第2页        SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);* 唯一约束：unique，值不能重复    1. 创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束        );        * 注意mysql中，唯一约束限定的列的值可以有多个null    2. 删除唯一约束        ALTER TABLE stu DROP INDEX phone_number;    3. 在创建表后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );        -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );        /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &apos;男&apos;,            telephone VARCHAR(11),            email VARCHAR(100)        );        /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）        [范式详解-知乎](https://www.zhihu.com/question/24696366/answer/29189700)</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. DQL:查询语句
    1. 排序查询
    2. 聚合函数
    3. 分组查询
    4.
      
    
    </summary>
    
      <category term="Java" scheme="www.friend-ma.top/categories/Java/"/>
    
      <category term="MySQL" scheme="www.friend-ma.top/categories/Java/MySQL/"/>
    
    
      <category term="MySQL" scheme="www.friend-ma.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基础</title>
    <link href="www.friend-ma.top/2019/05/24/Mysql%E5%9F%BA%E7%A1%80/"/>
    <id>www.friend-ma.top/2019/05/24/Mysql基础/</id>
    <published>2019-05-24T08:00:53.000Z</published>
    <updated>2019-05-24T08:01:50.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据库的基本概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;MySQL数据库软件&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="www.friend-ma.top/categories/Java/"/>
    
      <category term="MySQL" scheme="www.friend-ma.top/categories/Java/MySQL/"/>
    
    
      <category term="MySQL" scheme="www.friend-ma.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="www.friend-ma.top/2019/05/17/%E5%8F%8D%E5%B0%84/"/>
    <id>www.friend-ma.top/2019/05/17/反射/</id>
    <published>2019-05-17T06:03:55.000Z</published>
    <updated>2019-05-17T06:11:36.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo1 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        获取Class对象的方式：</span><br><span class="line">            1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象</span><br><span class="line">            2. 类名.class：通过类名的属性class获取</span><br><span class="line">            3. 对象.getClass()：getClass()方法在Object类中定义着。</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1.Class.forName(&quot;全类名&quot;)</span><br><span class="line">        Class cls1 = Class.forName(&quot;cn.itcast.domain.Person&quot;);</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        //2.类名.class</span><br><span class="line">        Class cls2 = Person.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        //3.对象.getClass()</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        Class cls3 = p.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        //== 比较三个对象</span><br><span class="line">        System.out.println(cls1 == cls2);//true</span><br><span class="line">        System.out.println(cls1 == cls3);//true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class c = Student.class;</span><br><span class="line">        System.out.println(c == cls1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     Class对象功能：</span><br><span class="line">         * 获取功能：</span><br><span class="line">         1. 获取成员变量们</span><br><span class="line">             * Field[] getFields()</span><br><span class="line">             * Field getField(String name)</span><br><span class="line"></span><br><span class="line">             * Field[] getDeclaredFields()</span><br><span class="line">             * Field getDeclaredField(String name)</span><br><span class="line">         2. 获取构造方法们</span><br><span class="line">             * Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">             * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line">             * Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">         3. 获取成员方法们：</span><br><span class="line">             * Method[] getMethods()</span><br><span class="line">             * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Method[] getDeclaredMethods()</span><br><span class="line">             * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">         4. 获取类名</span><br><span class="line">             * String getName()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //0.获取Person的Class对象</span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line">        /*</span><br><span class="line">             1. 获取成员变量们</span><br><span class="line">                 * Field[] getFields()</span><br><span class="line">                 * Field getField(String name)</span><br><span class="line"></span><br><span class="line">                 * Field[] getDeclaredFields()</span><br><span class="line">                 * Field getDeclaredField(String name)</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        //1.Field[] getFields()获取所有public修饰的成员变量</span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;------------&quot;);</span><br><span class="line">        //2.Field getField(String name)</span><br><span class="line">        Field a = personClass.getField(&quot;a&quot;);</span><br><span class="line">        //获取成员变量a 的值</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        Object value = a.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        //设置a的值</span><br><span class="line">        a.set(p,&quot;张三&quot;);</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===================&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        for (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">        //Field getDeclaredField(String name)</span><br><span class="line">        Field d = personClass.getDeclaredField(&quot;d&quot;);</span><br><span class="line">        //忽略访问权限修饰符的安全检查</span><br><span class="line">        d.setAccessible(true);//暴力反射</span><br><span class="line">        Object value2 = d.get(p);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     Class对象功能：</span><br><span class="line">         * 获取功能：</span><br><span class="line">         1. 获取成员变量们</span><br><span class="line">             * Field[] getFields()</span><br><span class="line">             * Field getField(String name)</span><br><span class="line"></span><br><span class="line">             * Field[] getDeclaredFields()</span><br><span class="line">             * Field getDeclaredField(String name)</span><br><span class="line">         2. 获取构造方法们</span><br><span class="line">             * Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">             * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line">             * Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">         3. 获取成员方法们：</span><br><span class="line">             * Method[] getMethods()</span><br><span class="line">             * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Method[] getDeclaredMethods()</span><br><span class="line">             * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">         4. 获取类名</span><br><span class="line">             * String getName()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //0.获取Person的Class对象</span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line">        /*</span><br><span class="line">            2. 获取构造方法们</span><br><span class="line">                 * Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">                 * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">                 * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line">                 * Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line">        Constructor constructor = personClass.getConstructor(String.class, int.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        //创建对象</span><br><span class="line">        Object person = constructor.newInstance(&quot;张三&quot;, 23);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor constructor1 = personClass.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">        //创建对象</span><br><span class="line">        Object person1 = constructor1.newInstance();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        Object o = personClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //constructor1.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     Class对象功能：</span><br><span class="line">         * 获取功能：</span><br><span class="line">         1. 获取成员变量们</span><br><span class="line">             * Field[] getFields()</span><br><span class="line">             * Field getField(String name)</span><br><span class="line"></span><br><span class="line">             * Field[] getDeclaredFields()</span><br><span class="line">             * Field getDeclaredField(String name)</span><br><span class="line">         2. 获取构造方法们</span><br><span class="line">             * Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">             * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span><br><span class="line">             * Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">         3. 获取成员方法们：</span><br><span class="line">             * Method[] getMethods()</span><br><span class="line">             * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Method[] getDeclaredMethods()</span><br><span class="line">             * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">         4. 获取类名</span><br><span class="line">             * String getName()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //0.获取Person的Class对象</span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line">        /*</span><br><span class="line">          3. 获取成员方法们：</span><br><span class="line">             * Method[] getMethods()</span><br><span class="line">             * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">             * Method[] getDeclaredMethods()</span><br><span class="line">             * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span><br><span class="line">         */</span><br><span class="line">        //获取指定名称的方法</span><br><span class="line">        Method eat_method = personClass.getMethod(&quot;eat&quot;);</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        //执行方法</span><br><span class="line">        eat_method.invoke(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Method eat_method2 = personClass.getMethod(&quot;eat&quot;, String.class);</span><br><span class="line">        //执行方法</span><br><span class="line">        eat_method2.invoke(p,&quot;饭&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">        //获取所有public修饰的方法</span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">            String name = method.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            //method.setAccessible(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取类名</span><br><span class="line">        String className = personClass.getName();</span><br><span class="line">        System.out.println(className);//cn.itcast.domain.Person</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //可以创建任意类的对象，可以执行任意方法</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法</span><br><span class="line">         */</span><br><span class="line">      /*  Person p = new Person();</span><br><span class="line">        p.eat();*/</span><br><span class="line">/*</span><br><span class="line">        Student stu = new Student();</span><br><span class="line">        stu.sleep();*/</span><br><span class="line"></span><br><span class="line">        //1.加载配置文件</span><br><span class="line">        //1.1创建Properties对象</span><br><span class="line">        Properties pro = new Properties();</span><br><span class="line">        //1.2加载配置文件，转换为一个集合</span><br><span class="line">        //1.2.1获取class目录下的配置文件</span><br><span class="line">        ClassLoader classLoader = ReflectTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(&quot;pro.properties&quot;);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        //2.获取配置文件中定义的数据</span><br><span class="line">        String className = pro.getProperty(&quot;className&quot;);</span><br><span class="line">        String methodName = pro.getProperty(&quot;methodName&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3.加载该类进内存</span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        //4.创建对象</span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        //5.获取方法对象</span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        //6.执行方法</span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射：框架设计的灵魂&quot;&gt;&lt;a href=&quot;#反射：框架设计的灵魂&quot; class=&quot;headerlink&quot; title=&quot;反射：框架设计的灵魂&quot;&gt;&lt;/a&gt;反射：框架设计的灵魂&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编
      
    
    </summary>
    
      <category term="Java" scheme="www.friend-ma.top/categories/Java/"/>
    
      <category term="基础" scheme="www.friend-ma.top/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="反射" scheme="www.friend-ma.top/categories/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="反射" scheme="www.friend-ma.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat&amp;Servlet笔记</title>
    <link href="www.friend-ma.top/2019/04/13/Tomcat_Servlet%E7%AC%94%E8%AE%B0/"/>
    <id>www.friend-ma.top/2019/04/13/Tomcat_Servlet笔记/</id>
    <published>2019-04-13T10:57:50.000Z</published>
    <updated>2019-05-17T06:06:52.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人        * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;</code></pre><pre><code>* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target({ElementType.TYPE})            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet {                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                String[] value() default {};//代表urlPatterns()属性配置                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                WebInitParam[] initParams() default {};                boolean asyncSupported() default false;                String smallIcon() default &quot;&quot;;                String largeIcon() default &quot;&quot;;                String description() default &quot;&quot;;                String displayName() default &quot;&quot;;            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. web相关概念回顾
2. web服务器软件：Tomcat
3. Servlet入门学习
&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="www.friend-ma.top/categories/Java/"/>
    
      <category term="JavaWeb" scheme="www.friend-ma.top/categories/Java/JavaWeb/"/>
    
    
      <category term="Tomcat" scheme="www.friend-ma.top/tags/Tomcat/"/>
    
      <category term="servlet" scheme="www.friend-ma.top/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>hexo分类无法显示</title>
    <link href="www.friend-ma.top/2019/04/12/hexo%E5%88%86%E7%B1%BB%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <id>www.friend-ma.top/2019/04/12/hexo分类无法显示问题/</id>
    <published>2019-04-12T10:57:50.000Z</published>
    <updated>2019-05-14T17:12:31.310Z</updated>
    
    <content type="html"><![CDATA[<p>步骤一：</p><p>由于默认是没有<code>tags</code>和<code>categories</code>的，命令行:</p><ul><li>hexo new page “tags”</li><li>hexo new page “categories”</li></ul><p>第二步：</p><p>编辑<code>\source\tags\index.md</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-04-11 00:35:13</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>编辑<code>\source\categories</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-11 01:01:07</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;步骤一：&lt;/p&gt;
&lt;p&gt;由于默认是没有&lt;code&gt;tags&lt;/code&gt;和&lt;code&gt;categories&lt;/code&gt;的，命令行:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hexo new page “tags”&lt;/li&gt;
&lt;li&gt;hexo new page “categories”&lt;
      
    
    </summary>
    
      <category term="hexo" scheme="www.friend-ma.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="www.friend-ma.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 图片无法显示</title>
    <link href="www.friend-ma.top/2019/04/12/hexo-%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>www.friend-ma.top/2019/04/12/hexo-图片无法显示/</id>
    <published>2019-04-12T10:57:50.000Z</published>
    <updated>2019-04-12T14:24:24.845Z</updated>
    
    <content type="html"><![CDATA[<p>遇到这样的问题</p><img src="/2019/04/12/hexo-图片无法显示/figure1.png" title="This is an example image"><p></p><h2>解决方法</h2><br>1.首先确认站点_config.yml（hexo根目录下的那个） 中有 post_asset_folder: true。(空一格)<br>Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder<br>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。<p></p><p>2.在hexo的目录下执行<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code>（需要等待一段时间）。</p><p>3.hexo n “demo”</p><p>4.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：<br>demo文件夹<br>–figure2.png<br>demo.md</p><p>图片要和文章所在的文件夹在一起，写成这样就可以了，在demo.md 插入你要插入的图片的位置写如下：</p><pre><code> {% asset_img figure2.png This is an example image %}  /*修改figure2.png，figure2.png应在[demo文件夹中]*/</code></pre><img src="/2019/04/12/hexo-图片无法显示/figure2.png" title="This is an example image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;遇到这样的问题&lt;/p&gt;
&lt;img src=&quot;/2019/04/12/hexo-图片无法显示/figure1.png&quot; title=&quot;This is an example image&quot;&gt;
&lt;p&gt;&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;br&gt;1.首先确认站点_config.yml（
      
    
    </summary>
    
      <category term="hexo" scheme="www.friend-ma.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="www.friend-ma.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>蒹葭</title>
    <link href="www.friend-ma.top/2019/04/10/hello-world/"/>
    <id>www.friend-ma.top/2019/04/10/hello-world/</id>
    <published>2019-04-10T12:29:15.656Z</published>
    <updated>2019-04-10T17:12:21.171Z</updated>
    
    <content type="html"><![CDATA[<p>蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。</p><p>蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。</p><p>蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。&lt;/p&gt;
&lt;p&gt;蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。&lt;/p&gt;
&lt;p&gt;蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中
      
    
    </summary>
    
      <category term="文学" scheme="www.friend-ma.top/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="诗经" scheme="www.friend-ma.top/tags/%E8%AF%97%E7%BB%8F/"/>
    
      <category term="古典文学" scheme="www.friend-ma.top/tags/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
</feed>
